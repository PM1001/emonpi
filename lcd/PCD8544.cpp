
#include "PCD8544.h"
#include <thread>

using namespace piHardware;
// An abs() :)
#define abs(a) (((a) < 0) ? -(a) : (a))

// bit set
#define _BV(bit) (0x1 << (bit))

// reduces how much is refreshed, which speeds it up!
// originally derived from Steve Evans/JCW's mod but cleaned up and optimized
//#define enablePartialUpdate
#if 0
static void PCD8544::setPixel(uint8_t x, uint8_t y, uint8_t color)
{
	if ((x >= LCDWIDTH) || (y >= LCDHEIGHT)){
		return;
	}
	// x is which column
	if (color){
		this->displayBuffer[x+ (y/8)*LCDWIDTH] |= _BV(y%8);
	}
	else{
		this->displayBuffer[x+ (y/8)*LCDWIDTH] &= ~_BV(y%8);
	}
}
#endif

void PCD8544::updateBoundingBox(uint8_t xmin, uint8_t ymin, uint8_t xmax, uint8_t ymax) {
#ifdef enablePartialUpdate
	if (xmin < xUpdateMin) {
		xUpdateMin = xmin;
	}
	if (xmax > xUpdateMax) {
		xUpdateMax = xmax;
	}
	if (ymin < yUpdateMin) {
		yUpdateMin = ymin;
	}
	if (ymax > yUpdateMax) {
		yUpdateMax = ymax;
	}
#endif
}

PCD8544::PCD8544(p_4094driverBCM* outDriv_,int strobeLine, int dcLine, int resetLine):outDriv(outDriv_),strobe(strobeLine),dc(dcLine),reset(resetLine){
    this->init(53);
    this->row = 0;
    this->col=0;
}

PCD8544::~PCD8544(){
}

void PCD8544::init(uint8_t contrast){
	this->textsize = 1;
	this->textcolor = BLACK;

	// toggle RST low to reset; CS low so it'll listen to us
	this->outDriv->ClearBitRaw(this->strobe);

	this->outDriv->ClearBitRaw(this->reset);
	std::this_thread::sleep_for (std::chrono::milliseconds((unsigned long)5));
	this->outDriv->SetBitRaw(this->reset);

	// get into the EXTENDED mode!
	this->command(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION );

	// LCD bias select (4 is optimal?)
	this->command(PCD8544_SETBIAS | 0x4);

	// set VOP
	if (this->contrast > 0x7f){
		this->contrast = 0x7f;
	}

	this->command( PCD8544_SETVOP | contrast); // Experimentally determined

	// normal mode
	this->command(PCD8544_FUNCTIONSET);

	// Set display to Normal
	this->command(PCD8544_DISPLAYCONTROL | PCD8544_DISPLAYNORMAL);

	// set up a bounding box for screen updates
	this->updateBoundingBox(0, 0, LCDWIDTH-1, LCDHEIGHT-1);

}

void PCD8544::drawbitmap(uint8_t x, uint8_t y,const uint8_t *bitmap, uint8_t w, uint8_t h,uint8_t color){
	uint8_t j,i;
	for ( j=0; j<h; j++){
		for ( i=0; i<w; i++ ){
			if (*(bitmap + i + (j/8)*w) & _BV(j%8)){
				this->setPixel(x+i, y+j, color);
			}
		}
	}
	this->updateBoundingBox(x, y, x+w, y+h);
}

void PCD8544::drawstring(uint8_t x, uint8_t y, const char *c){
	cursor_x = x;
	cursor_y = y;
	while (*c){
		this->write(*c++);
	}
}

void PCD8544::drawchar(uint8_t x, uint8_t y, char c){
	if ((y > LCDHEIGHT)|| ((x+5) > LCDWIDTH+1)) {
		//return;
	}
	uint8_t i,j;
	for ( i =0; i<5; i++ ){
		uint8_t d = *(font+(c*5)+i);
		uint8_t j;
		for (j = 0; j<8; j++){
			if (d & _BV(j)){
				this->togglePixel(x+i, y+j);
			}
			else{
				//this->togglePixel(x+i, y+j, !textcolor);
			}
		}
	}

	//for ( j = 0; j<8; j++){
	//	this->togglePixel(x+5, y+j, !textcolor);
	//}
	this->updateBoundingBox(x, y, x+5, y + 8);
}

uint8_t PCD8544::drawchar(uint8_t x, uint8_t y, char c,fontAbstract* font_current){
	/* Font table in MikroElecktronica format
	   - multi row fonts allowed (more than 8 pixels high)
	   - variable width fonts allowed
	   a complete column is written before moving to the next */
	
	if (font_current==nullptr){
		this->drawchar(x,y,c);
		return 6;
	}

	uint8_t i;
	uint8_t var_width;
	/* The first byte per character is always the width of the character */
	var_width = font_current->varWidth(c);
	
	for ( i = 0; i < var_width; i++ ) {
		uint8_t j;
		for ( j = 0; j < font_current->bytesHigh() ; j++ ) {
			uint8_t dat = font_current->getcharbyte(c, i*font_current->bytesHigh() + j );
			uint8_t bit;
			for (bit = 0; bit < 8; bit++) {				
				if (x+i > LCDWIDTH || y+j*8+bit > LCDHEIGHT) {
					/* Don't write past the dimensions of the LCD, skip the entire char */
					return 0;
				}				
				/* We should not write if the y bit exceeds font height */
				if ((j*8 + bit) >= font_current->height()) {
					/* Skip the bit */
					continue;
				}				
				if (dat & (1<<bit)) {
					this->togglePixel(x+i,y+j*8+bit);
				} 
				//else {
				//	this->togglePixel(x+i,y+j*8+bit,WHITE);
				//}
			}									
		}				
	}
	return var_width;	

};
	

void PCD8544::write(const char c,fontAbstract* font){
	int width;
	int height = 8;
	if(font!=nullptr){
		height = font->height();
	}
	if (c == '\n'){
		cursor_y += textsize*8;
		cursor_x = 0;
	}
	else if (c == '\r')	{
		// skip em
	}
	else{
		width = this->drawchar(cursor_x, cursor_y, c,font);
		cursor_x += textsize*width;
		if (cursor_x > (LCDWIDTH-5)){
			cursor_x = 0;
			cursor_y+=height;
		}
		if (cursor_y >= LCDHEIGHT){
			cursor_y = 0;
		}
	}
}

void PCD8544::setCursor(uint8_t x, uint8_t y){
	cursor_x = x;
	cursor_y = y;
}

// bresenham's algorithm - thx wikpedia
void PCD8544::drawline(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, uint8_t color){
	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep){
		swap(x0, y0);
		swap(x1, y1);
	}

	if (x0 > x1){
		swap(x0, x1);
		swap(y0, y1);
	}

	// much faster to put the test here, since we've already sorted the points
	this->updateBoundingBox(x0, y0, x1, y1);

	uint8_t dx, dy;
	dx = x1 - x0;
	dy = abs(y1 - y0);

	int8_t err = dx / 2;
	int8_t ystep;

	if (y0 < y1){
		ystep = 1;
	} 
	else{
		ystep = -1;
	}

	for (; x0<=x1; x0++){
		if (steep){
			this->setPixel(y0, x0, color);
		}
		else{
			this->setPixel(x0, y0, color);
		}
		err -= dy;
		if (err < 0){
			y0 += ystep;
			err += dx;
		}
	}
}

// filled rectangle
void PCD8544::fillrect(uint8_t x, uint8_t y, uint8_t w, uint8_t h,  uint8_t color){	
// stupidest version - just pixels - but fast with internal buffer!
	uint8_t i,j;
	for ( i=x; i<x+w; i++){
		for ( j=y; j<y+h; j++){
			this->setPixel(i, j, color);
		}
	}
	updateBoundingBox(x, y, x+w, y+h);
}

// draw a rectangle
void PCD8544::drawrect(uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint8_t color){
	// stupidest version - just pixels - but fast with internal buffer!
	uint8_t i;
	for ( i=x; i<x+w; i++) {
		this->setPixel(i, y, color);
		this->setPixel(i, y+h-1, color);
	}
	for ( i=y; i<y+h; i++) {
		this->setPixel(x, i, color);
		this->setPixel(x+w-1, i, color);
	}

	updateBoundingBox(x, y, x+w, y+h);
}

// draw a circle outline
void PCD8544::drawcircle(uint8_t x0, uint8_t y0, uint8_t r, uint8_t color){
	updateBoundingBox(x0-r, y0-r, x0+r, y0+r);

	int8_t f = 1 - r;
	int8_t ddF_x = 1;
	int8_t ddF_y = -2 * r;
	int8_t x = 0;
	int8_t y = r;

	this->setPixel(x0, y0+r, color);
	this->setPixel(x0, y0-r, color);
	this->setPixel(x0+r, y0, color);
	this->setPixel(x0-r, y0, color);

	while (x<y)	{
		if (f >= 0)	{
			y--;
			ddF_y += 2;
			f += ddF_y;
		}
		x++;
		ddF_x += 2;
		f += ddF_x;

		this->setPixel(x0 + x, y0 + y, color);
		this->setPixel(x0 - x, y0 + y, color);
		this->setPixel(x0 + x, y0 - y, color);
		this->setPixel(x0 - x, y0 - y, color);

		this->setPixel(x0 + y, y0 + x, color);
		this->setPixel(x0 - y, y0 + x, color);
		this->setPixel(x0 + y, y0 - x, color);
		this->setPixel(x0 - y, y0 - x, color);

	}
}

void PCD8544::fillcircle(uint8_t x0, uint8_t y0, uint8_t r, uint8_t color){
	updateBoundingBox(x0-r, y0-r, x0+r, y0+r);
	int8_t f = 1 - r;
	int8_t ddF_x = 1;
	int8_t ddF_y = -2 * r;
	int8_t x = 0;
	int8_t y = r;
	uint8_t i;

	for (i=y0-r; i<=y0+r; i++){
		this->setPixel(x0, i, color);
	}

	while (x<y){
		if (f >= 0){
			y--;
			ddF_y += 2;
			f += ddF_y;
		}
		x++;
		ddF_x += 2;
		f += ddF_x;

		for ( i=y0-y; i<=y0+y; i++){
			this->setPixel(x0+x, i, color);
			this->setPixel(x0-x, i, color);
		}
		for ( i=y0-x; i<=y0+x; i++){
			this->setPixel(x0+y, i, color);
			this->setPixel(x0-y, i, color);
		}
	}
}

// the most basic function, set a single pixel
void PCD8544::setPixel(uint8_t x, uint8_t y, uint8_t color){
	if ((x >= LCDWIDTH) || (y >= LCDHEIGHT)){
		return;
	}

	// x is which column
	if (color==BLACK){
		this->displayBuffer[x+ (y/8)*LCDWIDTH] |= _BV(y%8);
	}
	else if (color==WHITE){
		this->displayBuffer[x+ (y/8)*LCDWIDTH] &= ~_BV(y%8);
	}
	else{
		this->displayBuffer[x+ (y/8)*LCDWIDTH] ^= _BV(y%8);
	}
	this->updateBoundingBox(x,y,x,y);
}
// the most basic function, set a single pixel
void PCD8544::togglePixel(uint8_t x, uint8_t y){
	if ((x >= LCDWIDTH) || (y >= LCDHEIGHT)){
		return;
	}

	// x is which column
	this->displayBuffer[x+ (y/8)*LCDWIDTH] ^= _BV(y%8);
	
	this->updateBoundingBox(x,y,x,y);
}
// the most basic function, get a single pixel
uint8_t PCD8544::getPixel(uint8_t x, uint8_t y){
	if ((x >= LCDWIDTH) || (y >= LCDHEIGHT))
		return 0;

	return (this->displayBuffer[x+ (y/8)*LCDWIDTH] >> (7-(y%8))) & 0x1;
}

void PCD8544::spiWrite(uint8_t LCDout){

	this->outDriv->ClearBitRaw(this->strobe);
    //usleep(10);   // commands need > 37us to settle
    this->outDriv->WriteSpiRaw(LCDout);
    //usleep(10);   // commands need > 37us to settle
	this->outDriv->SetBitRaw(this->strobe);
}

inline void PCD8544::command(uint8_t c){
	this->outDriv->ClearBitRaw( this->dc);
	this->spiWrite(c);
}

inline void PCD8544::data(uint8_t c){
	this->outDriv->SetBitRaw( this->dc);
	this->spiWrite(c);
}

void PCD8544::setContrast(uint8_t val){
	if (val > 0x7f) {
		val = 0x7f;
	}
	this->command(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION );
	this->command( PCD8544_SETVOP | val);
	this->command(PCD8544_FUNCTIONSET);
}

void PCD8544::display(void){
	uint8_t col, maxcol, p;

	for(p = 0; p < 6; p++){
#ifdef enablePartialUpdate
		// check if this page is part of update
		if ( yUpdateMin >= ((p+1)*8) ){
			continue;   // nope, skip it!
		}
		if (yUpdateMax < p*8){
			break;
		}
#endif

		this->command(PCD8544_SETYADDR | p);


#ifdef enablePartialUpdate
		col = xUpdateMin;
		maxcol = xUpdateMax;
#else
		// start at the beginning of the row
		col = 0;
		maxcol = LCDWIDTH-1;
#endif

		this->command(PCD8544_SETXADDR | col);

		for(; col <= maxcol; col++) {
			//uart_putw_dec(col);
			//uart_putchar(' ');
			this->data(this->displayBuffer[(LCDWIDTH*p)+col]);
		}
	}

	this->command(PCD8544_SETYADDR );  // no idea why this is necessary but it is to finish the last byte?
#ifdef enablePartialUpdate
	xUpdateMin = LCDWIDTH - 1;
	xUpdateMax = 0;
	yUpdateMin = LCDHEIGHT-1;
	yUpdateMax = 0;
#endif

}

// clear everything
void PCD8544::clear(void) {
	//memset(this->displayBuffer, 0, LCDWIDTH*LCDHEIGHT/8);
	uint32_t i;
	for ( i = 0; i < LCDWIDTH*LCDHEIGHT/8 ; i++){
		this->displayBuffer[i] = 0;
	}
	updateBoundingBox(0, 0, LCDWIDTH-1, LCDHEIGHT-1);
	cursor_y = cursor_x = 0;
}

void PCD8544::printTime(time_t t,fontAbstract* font){
    struct tm *now = localtime( & t );
    this->write(now->tm_hour/10+'0',font);
    this->write(now->tm_hour%10+'0',font);
    if(now->tm_sec%2==0){
    	this->write(':',font);
    }
    else{
    	this->write(' ',font);	
    }
    this->write(now->tm_min/10+'0',font);
    this->write(now->tm_min%10+'0',font);
    this->write(' ',font);
    #if 0
    this->write(':');
    this->write(now->tm_sec/10+'0');
    this->write(now->tm_sec%10+'0');
    #endif
}
void PCD8544::printRunTime(time_t t,time_t end,fontAbstract* font){
    double seconds = difftime(end,t);
    int tm_min = ((int)seconds)/60;
    int tm_sec = ((int)seconds)%60;
    this->write(tm_min/10+'0',font);
    this->write(tm_min%10+'0',font);
    this->write(':');
    this->write(tm_sec/10+'0',font);
    this->write(tm_sec%10+'0',font);
}

void PCD8544::printInt(int num,int pad){
	//int factor = 1;
	std::string mynums{};
	while (num!=0){
		int cur_num = num%10;
		//factor *= 10;
		num/=10;
		mynums = char('0'+cur_num) + mynums;
		--pad;
	}
	while(pad>0){
		mynums = '0'+mynums;
		--pad;
	}
	this->print_string(mynums.c_str());
}

const unsigned char  PCD8544::font[] = {
				0x00, 0x00, 0x00, 0x00, 0x00,
				0x3E, 0x5B, 0x4F, 0x5B, 0x3E,
				0x3E, 0x6B, 0x4F, 0x6B, 0x3E,
				0x1C, 0x3E, 0x7C, 0x3E, 0x1C,
				0x18, 0x3C, 0x7E, 0x3C, 0x18,
				0x1C, 0x57, 0x7D, 0x57, 0x1C,
				0x1C, 0x5E, 0x7F, 0x5E, 0x1C,
				0x00, 0x18, 0x3C, 0x18, 0x00,
				0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
				0x00, 0x18, 0x24, 0x18, 0x00,
				0xFF, 0xE7, 0xDB, 0xE7, 0xFF,
				0x30, 0x48, 0x3A, 0x06, 0x0E,
				0x26, 0x29, 0x79, 0x29, 0x26,
				0x40, 0x7F, 0x05, 0x05, 0x07,
				0x40, 0x7F, 0x05, 0x25, 0x3F,
				0x5A, 0x3C, 0xE7, 0x3C, 0x5A,
				0x7F, 0x3E, 0x1C, 0x1C, 0x08,
				0x08, 0x1C, 0x1C, 0x3E, 0x7F,
				0x14, 0x22, 0x7F, 0x22, 0x14,
				0x5F, 0x5F, 0x00, 0x5F, 0x5F,
				0x06, 0x09, 0x7F, 0x01, 0x7F,
				0x00, 0x66, 0x89, 0x95, 0x6A,
				0x60, 0x60, 0x60, 0x60, 0x60,
				0x94, 0xA2, 0xFF, 0xA2, 0x94,
				0x08, 0x04, 0x7E, 0x04, 0x08,
				0x10, 0x20, 0x7E, 0x20, 0x10,
				0x08, 0x08, 0x2A, 0x1C, 0x08,
				0x08, 0x1C, 0x2A, 0x08, 0x08,
				0x1E, 0x10, 0x10, 0x10, 0x10,
				0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
				0x30, 0x38, 0x3E, 0x38, 0x30,
				0x06, 0x0E, 0x3E, 0x0E, 0x06,
				0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x5F, 0x00, 0x00,
				0x00, 0x07, 0x00, 0x07, 0x00,
				0x14, 0x7F, 0x14, 0x7F, 0x14,
				0x24, 0x2A, 0x7F, 0x2A, 0x12,
				0x23, 0x13, 0x08, 0x64, 0x62,
				0x36, 0x49, 0x56, 0x20, 0x50,
				0x00, 0x08, 0x07, 0x03, 0x00,
				0x00, 0x1C, 0x22, 0x41, 0x00,
				0x00, 0x41, 0x22, 0x1C, 0x00,
				0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
				0x08, 0x08, 0x3E, 0x08, 0x08,
				0x00, 0x80, 0x70, 0x30, 0x00,
				0x08, 0x08, 0x08, 0x08, 0x08,
				0x00, 0x00, 0x60, 0x60, 0x00,
				0x20, 0x10, 0x08, 0x04, 0x02,
				0x3E, 0x51, 0x49, 0x45, 0x3E,
				0x00, 0x42, 0x7F, 0x40, 0x00,
				0x72, 0x49, 0x49, 0x49, 0x46,
				0x21, 0x41, 0x49, 0x4D, 0x33,
				0x18, 0x14, 0x12, 0x7F, 0x10,
				0x27, 0x45, 0x45, 0x45, 0x39,
				0x3C, 0x4A, 0x49, 0x49, 0x31,
				0x41, 0x21, 0x11, 0x09, 0x07,
				0x36, 0x49, 0x49, 0x49, 0x36,
				0x46, 0x49, 0x49, 0x29, 0x1E,
				0x00, 0x00, 0x14, 0x00, 0x00,
				0x00, 0x40, 0x34, 0x00, 0x00,
				0x00, 0x08, 0x14, 0x22, 0x41,
				0x14, 0x14, 0x14, 0x14, 0x14,
				0x00, 0x41, 0x22, 0x14, 0x08,
				0x02, 0x01, 0x59, 0x09, 0x06,
				0x3E, 0x41, 0x5D, 0x59, 0x4E,
				0x7C, 0x12, 0x11, 0x12, 0x7C,
				0x7F, 0x49, 0x49, 0x49, 0x36,
				0x3E, 0x41, 0x41, 0x41, 0x22,
				0x7F, 0x41, 0x41, 0x41, 0x3E,
				0x7F, 0x49, 0x49, 0x49, 0x41,
				0x7F, 0x09, 0x09, 0x09, 0x01,
				0x3E, 0x41, 0x41, 0x51, 0x73,
				0x7F, 0x08, 0x08, 0x08, 0x7F,
				0x00, 0x41, 0x7F, 0x41, 0x00,
				0x20, 0x40, 0x41, 0x3F, 0x01,
				0x7F, 0x08, 0x14, 0x22, 0x41,
				0x7F, 0x40, 0x40, 0x40, 0x40,
				0x7F, 0x02, 0x1C, 0x02, 0x7F,
				0x7F, 0x04, 0x08, 0x10, 0x7F,
				0x3E, 0x41, 0x41, 0x41, 0x3E,
				0x7F, 0x09, 0x09, 0x09, 0x06,
				0x3E, 0x41, 0x51, 0x21, 0x5E,
				0x7F, 0x09, 0x19, 0x29, 0x46,
				0x26, 0x49, 0x49, 0x49, 0x32,
				0x03, 0x01, 0x7F, 0x01, 0x03,
				0x3F, 0x40, 0x40, 0x40, 0x3F,
				0x1F, 0x20, 0x40, 0x20, 0x1F,
				0x3F, 0x40, 0x38, 0x40, 0x3F,
				0x63, 0x14, 0x08, 0x14, 0x63,
				0x03, 0x04, 0x78, 0x04, 0x03,
				0x61, 0x59, 0x49, 0x4D, 0x43,
				0x00, 0x7F, 0x41, 0x41, 0x41,
				0x02, 0x04, 0x08, 0x10, 0x20,
				0x00, 0x41, 0x41, 0x41, 0x7F,
				0x04, 0x02, 0x01, 0x02, 0x04,
				0x40, 0x40, 0x40, 0x40, 0x40,
				0x00, 0x03, 0x07, 0x08, 0x00,
				0x20, 0x54, 0x54, 0x78, 0x40,
				0x7F, 0x28, 0x44, 0x44, 0x38,
				0x38, 0x44, 0x44, 0x44, 0x28,
				0x38, 0x44, 0x44, 0x28, 0x7F,
				0x38, 0x54, 0x54, 0x54, 0x18,
				0x00, 0x08, 0x7E, 0x09, 0x02,
				0x18, 0xA4, 0xA4, 0x9C, 0x78,
				0x7F, 0x08, 0x04, 0x04, 0x78,
				0x00, 0x44, 0x7D, 0x40, 0x00,
				0x20, 0x40, 0x40, 0x3D, 0x00,
				0x7F, 0x10, 0x28, 0x44, 0x00,
				0x00, 0x41, 0x7F, 0x40, 0x00,
				0x7C, 0x04, 0x78, 0x04, 0x78,
				0x7C, 0x08, 0x04, 0x04, 0x78,
				0x38, 0x44, 0x44, 0x44, 0x38,
				0xFC, 0x18, 0x24, 0x24, 0x18,
				0x18, 0x24, 0x24, 0x18, 0xFC,
				0x7C, 0x08, 0x04, 0x04, 0x08,
				0x48, 0x54, 0x54, 0x54, 0x24,
				0x04, 0x04, 0x3F, 0x44, 0x24,
				0x3C, 0x40, 0x40, 0x20, 0x7C,
				0x1C, 0x20, 0x40, 0x20, 0x1C,
				0x3C, 0x40, 0x30, 0x40, 0x3C,
				0x44, 0x28, 0x10, 0x28, 0x44,
				0x4C, 0x90, 0x90, 0x90, 0x7C,
				0x44, 0x64, 0x54, 0x4C, 0x44,
				0x00, 0x08, 0x36, 0x41, 0x00,
				0x00, 0x00, 0x77, 0x00, 0x00,
				0x00, 0x41, 0x36, 0x08, 0x00,
				0x02, 0x01, 0x02, 0x04, 0x02,
				0x3C, 0x26, 0x23, 0x26, 0x3C,
				0x1E, 0xA1, 0xA1, 0x61, 0x12,
				0x3A, 0x40, 0x40, 0x20, 0x7A,
				0x38, 0x54, 0x54, 0x55, 0x59,
				0x21, 0x55, 0x55, 0x79, 0x41,
				0x21, 0x54, 0x54, 0x78, 0x41,
				0x21, 0x55, 0x54, 0x78, 0x40,
				0x20, 0x54, 0x55, 0x79, 0x40,
				0x0C, 0x1E, 0x52, 0x72, 0x12,
				0x39, 0x55, 0x55, 0x55, 0x59,
				0x39, 0x54, 0x54, 0x54, 0x59,
				0x39, 0x55, 0x54, 0x54, 0x58,
				0x00, 0x00, 0x45, 0x7C, 0x41,
				0x00, 0x02, 0x45, 0x7D, 0x42,
				0x00, 0x01, 0x45, 0x7C, 0x40,
				0xF0, 0x29, 0x24, 0x29, 0xF0,
				0xF0, 0x28, 0x25, 0x28, 0xF0,
				0x7C, 0x54, 0x55, 0x45, 0x00,
				0x20, 0x54, 0x54, 0x7C, 0x54,
				0x7C, 0x0A, 0x09, 0x7F, 0x49,
				0x32, 0x49, 0x49, 0x49, 0x32,
				0x32, 0x48, 0x48, 0x48, 0x32,
				0x32, 0x4A, 0x48, 0x48, 0x30,
				0x3A, 0x41, 0x41, 0x21, 0x7A,
				0x3A, 0x42, 0x40, 0x20, 0x78,
				0x00, 0x9D, 0xA0, 0xA0, 0x7D,
				0x39, 0x44, 0x44, 0x44, 0x39,
				0x3D, 0x40, 0x40, 0x40, 0x3D,
				0x3C, 0x24, 0xFF, 0x24, 0x24,
				0x48, 0x7E, 0x49, 0x43, 0x66,
				0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
				0xFF, 0x09, 0x29, 0xF6, 0x20,
				0xC0, 0x88, 0x7E, 0x09, 0x03,
				0x20, 0x54, 0x54, 0x79, 0x41,
				0x00, 0x00, 0x44, 0x7D, 0x41,
				0x30, 0x48, 0x48, 0x4A, 0x32,
				0x38, 0x40, 0x40, 0x22, 0x7A,
				0x00, 0x7A, 0x0A, 0x0A, 0x72,
				0x7D, 0x0D, 0x19, 0x31, 0x7D,
				0x26, 0x29, 0x29, 0x2F, 0x28,
				0x26, 0x29, 0x29, 0x29, 0x26,
				0x30, 0x48, 0x4D, 0x40, 0x20,
				0x38, 0x08, 0x08, 0x08, 0x08,
				0x08, 0x08, 0x08, 0x08, 0x38,
				0x2F, 0x10, 0xC8, 0xAC, 0xBA,
				0x2F, 0x10, 0x28, 0x34, 0xFA,
				0x00, 0x00, 0x7B, 0x00, 0x00,
				0x08, 0x14, 0x2A, 0x14, 0x22,
				0x22, 0x14, 0x2A, 0x14, 0x08,
				0xAA, 0x00, 0x55, 0x00, 0xAA,
				0xAA, 0x55, 0xAA, 0x55, 0xAA,
				0x00, 0x00, 0x00, 0xFF, 0x00,
				0x10, 0x10, 0x10, 0xFF, 0x00,
				0x14, 0x14, 0x14, 0xFF, 0x00,
				0x10, 0x10, 0xFF, 0x00, 0xFF,
				0x10, 0x10, 0xF0, 0x10, 0xF0,
				0x14, 0x14, 0x14, 0xFC, 0x00,
				0x14, 0x14, 0xF7, 0x00, 0xFF,
				0x00, 0x00, 0xFF, 0x00, 0xFF,
				0x14, 0x14, 0xF4, 0x04, 0xFC,
				0x14, 0x14, 0x17, 0x10, 0x1F,
				0x10, 0x10, 0x1F, 0x10, 0x1F,
				0x14, 0x14, 0x14, 0x1F, 0x00,
				0x10, 0x10, 0x10, 0xF0, 0x00,
				0x00, 0x00, 0x00, 0x1F, 0x10,
				0x10, 0x10, 0x10, 0x1F, 0x10,
				0x10, 0x10, 0x10, 0xF0, 0x10,
				0x00, 0x00, 0x00, 0xFF, 0x10,
				0x10, 0x10, 0x10, 0x10, 0x10,
				0x10, 0x10, 0x10, 0xFF, 0x10,
				0x00, 0x00, 0x00, 0xFF, 0x14,
				0x00, 0x00, 0xFF, 0x00, 0xFF,
				0x00, 0x00, 0x1F, 0x10, 0x17,
				0x00, 0x00, 0xFC, 0x04, 0xF4,
				0x14, 0x14, 0x17, 0x10, 0x17,
				0x14, 0x14, 0xF4, 0x04, 0xF4,
				0x00, 0x00, 0xFF, 0x00, 0xF7,
				0x14, 0x14, 0x14, 0x14, 0x14,
				0x14, 0x14, 0xF7, 0x00, 0xF7,
				0x14, 0x14, 0x14, 0x17, 0x14,
				0x10, 0x10, 0x1F, 0x10, 0x1F,
				0x14, 0x14, 0x14, 0xF4, 0x14,
				0x10, 0x10, 0xF0, 0x10, 0xF0,
				0x00, 0x00, 0x1F, 0x10, 0x1F,
				0x00, 0x00, 0x00, 0x1F, 0x14,
				0x00, 0x00, 0x00, 0xFC, 0x14,
				0x00, 0x00, 0xF0, 0x10, 0xF0,
				0x10, 0x10, 0xFF, 0x10, 0xFF,
				0x14, 0x14, 0x14, 0xFF, 0x14,
				0x10, 0x10, 0x10, 0x1F, 0x00,
				0x00, 0x00, 0x00, 0xF0, 0x10,
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
				0xFF, 0xFF, 0xFF, 0x00, 0x00,
				0x00, 0x00, 0x00, 0xFF, 0xFF,
				0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
				0x38, 0x44, 0x44, 0x38, 0x44,
				0x7C, 0x2A, 0x2A, 0x3E, 0x14,
				0x7E, 0x02, 0x02, 0x06, 0x06,
				0x02, 0x7E, 0x02, 0x7E, 0x02,
				0x63, 0x55, 0x49, 0x41, 0x63,
				0x38, 0x44, 0x44, 0x3C, 0x04,
				0x40, 0x7E, 0x20, 0x1E, 0x20,
				0x06, 0x02, 0x7E, 0x02, 0x02,
				0x99, 0xA5, 0xE7, 0xA5, 0x99,
				0x1C, 0x2A, 0x49, 0x2A, 0x1C,
				0x4C, 0x72, 0x01, 0x72, 0x4C,
				0x30, 0x4A, 0x4D, 0x4D, 0x30,
				0x30, 0x48, 0x78, 0x48, 0x30,
				0xBC, 0x62, 0x5A, 0x46, 0x3D,
				0x3E, 0x49, 0x49, 0x49, 0x00,
				0x7E, 0x01, 0x01, 0x01, 0x7E,
				0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
				0x44, 0x44, 0x5F, 0x44, 0x44,
				0x40, 0x51, 0x4A, 0x44, 0x40,
				0x40, 0x44, 0x4A, 0x51, 0x40,
				0x00, 0x00, 0xFF, 0x01, 0x03,
				0xE0, 0x80, 0xFF, 0x00, 0x00,
				0x08, 0x08, 0x6B, 0x6B, 0x08,
				0x36, 0x12, 0x36, 0x24, 0x36,
				0x06, 0x0F, 0x09, 0x0F, 0x06,
				0x00, 0x00, 0x18, 0x18, 0x00,
				0x00, 0x00, 0x10, 0x10, 0x00,
				0x30, 0x40, 0xFF, 0x01, 0x01,
				0x00, 0x1F, 0x01, 0x01, 0x1E,
				0x00, 0x19, 0x1D, 0x17, 0x12,
				0x00, 0x3C, 0x3C, 0x3C, 0x3C,
				0x00, 0x00, 0x00, 0x00, 0x00,
		};